# Copyright (c) 2025
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Navigation client for semantic navigation."""

import math
import threading
from typing import Optional

import rclpy
from geometry_msgs.msg import PoseStamped
from nav2_simple_commander.robot_navigator import BasicNavigator, TaskResult
from rclpy.executors import MultiThreadedExecutor


class NavigationClient:
    """Client for Nav2 navigation operations."""

    _instance: Optional['NavigationClient'] = None
    _lock = threading.Lock()
    _rclpy_initialized = False
    _executor: Optional[MultiThreadedExecutor] = None
    _executor_thread: Optional[threading.Thread] = None

    def __init__(self):
        """Initialize navigation client."""
        self._navigator: Optional[BasicNavigator] = None
        self._ensure_rclpy_initialized()

    @classmethod
    def get_instance(cls) -> 'NavigationClient':
        """Get singleton instance of NavigationClient.

        Returns
        -------
        NavigationClient
            The singleton instance.
        """
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance

    @classmethod
    def _ensure_rclpy_initialized(cls) -> None:
        """Ensure rclpy is initialized (lazy initialization)."""
        if not cls._rclpy_initialized:
            with cls._lock:
                if not cls._rclpy_initialized:
                    if not rclpy.ok():
                        rclpy.init()
                    cls._rclpy_initialized = True

    @classmethod
    def _start_executor(cls) -> None:
        """Start ROS2 executor in background thread."""
        if cls._executor is None:
            cls._executor = MultiThreadedExecutor()
            cls._executor_thread = threading.Thread(
                target=cls._executor.spin,
                daemon=True
            )
            cls._executor_thread.start()

    @property
    def navigator(self) -> BasicNavigator:
        """Get or create the navigator instance.

        Returns
        -------
        BasicNavigator
            The Nav2 navigator instance.
        """
        if self._navigator is None:
            # Start executor before creating navigator
            self._start_executor()
            self._navigator = BasicNavigator(executor=self._executor)
        return self._navigator

    def create_pose_stamped(
        self,
        x: float,
        y: float,
        yaw: float = 0.0,
        frame_id: str = 'map'
    ) -> PoseStamped:
        """Create a PoseStamped message from coordinates.

        Parameters
        ----------
        x : float
            X coordinate.
        y : float
            Y coordinate.
        yaw : float
            Orientation in radians.
        frame_id : str
            Frame ID (default: 'map').

        Returns
        -------
        PoseStamped
            The pose message.
        """
        pose = PoseStamped()
        pose.header.frame_id = frame_id
        pose.header.stamp = self.navigator.get_clock().now().to_msg()
        pose.pose.position.x = x
        pose.pose.position.y = y
        pose.pose.position.z = 0.0

        # Convert yaw to quaternion
        pose.pose.orientation.w = math.cos(yaw / 2.0)
        pose.pose.orientation.z = math.sin(yaw / 2.0)

        return pose

    def navigate_to_pose(
        self,
        x: float,
        y: float,
        yaw: float,
        frame_id: str = 'map'
    ) -> str:
        """Navigate to a pose.

        Parameters
        ----------
        x : float
            X coordinate.
        y : float
            Y coordinate.
        yaw : float
            Orientation in radians.
        frame_id : str
            Frame ID (default: 'map').

        Returns
        -------
        str
            Result message.
        """
        import time

        # Create and send navigation goal
        pose = self.create_pose_stamped(x, y, yaw, frame_id)

        try:
            self.navigator.goToPose(pose)
        except Exception as e:
            return f"Failed to send navigation goal: {str(e)}"

        # Wait for navigation to complete with periodic feedback
        start_time = time.time()
        last_feedback = start_time

        while not self.navigator.isTaskComplete():
            time.sleep(0.1)  # Sleep instead of busy-wait

            # Provide periodic feedback
            current_time = time.time()
            if current_time - last_feedback > 2.0:  # Every 2 seconds
                elapsed = current_time - start_time
                print(f"Navigation in progress... ({elapsed:.1f}s elapsed)")
                last_feedback = current_time

        # Get final result
        result = self.navigator.getResult()
        elapsed = time.time() - start_time

        if result == TaskResult.SUCCEEDED:
            return f"Successfully navigated to ({x:.2f}, {y:.2f}, yaw={yaw:.2f}) in {elapsed:.1f}s"
        elif result == TaskResult.CANCELED:
            return f"Navigation was canceled after {elapsed:.1f}s"
        elif result == TaskResult.FAILED:
            return f"Navigation failed to reach ({x:.2f}, {y:.2f}) after {elapsed:.1f}s"
        else:
            return f"Navigation completed with unknown result: {result} after {elapsed:.1f}s"

    def get_robot_pose(self) -> Optional[PoseStamped]:
        """Get current robot pose.

        Returns
        -------
        Optional[PoseStamped]
            Current robot pose or None if unavailable.
        """
        try:
            return self.navigator.getCurrentPose()
        except Exception:
            return None

    def cancel_navigation(self) -> str:
        """Cancel current navigation task.

        Returns
        -------
        str
            Result message.
        """
        self.navigator.cancelTask()
        return "Navigation canceled"
